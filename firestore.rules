    rules_version = '2';
    service cloud.firestore {

      match /databases/{database}/documents {

        // Helper function to check if the requesting user is an admin
        function isAdmin() {
          // Check the requesting user's role from their Firestore document
          return exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
                 get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
        }

        // Rules for users collection
        match /users/{userId} {
          // Allow users to read their own data
          // Allow admins to read any user data
          // Allow any authenticated user to read vendor profiles for the 'Available Vendors' list.
          allow get: if request.auth != null && 
                        (request.auth.uid == userId || // User reads own profile
                         isAdmin() ||                  // Admin reads any profile
                         resource.data.role == 'vendor'); // Any authenticated user reads vendor profile
          // Allow any authenticated user to LIST the users collection.
          // Firestore will implicitly filter results based on the 'get' rule above.
          // This allows the query for available vendors to work.
          allow list: if request.auth != null;
          // Allow users to create their own account data
          allow create: if request.auth != null && request.auth.uid == userId;
          // Allow users to update their own data (specific fields TBD)
          allow update: if request.auth != null && request.auth.uid == userId && 
                         // Check the role of the user making the request, not the incoming data
                         get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'vendor' &&
                         (
                           // Allow updating location fields - more flexible approach
                           (request.resource.data.diff(resource.data).affectedKeys()
                             .hasAny(['location', 'lastLocationUpdate']) && 
                            request.resource.data.diff(resource.data).affectedKeys()
                             .hasOnly(['location', 'lastLocationUpdate'])) ||
                           // Allow updating status and radius
                           request.resource.data.diff(resource.data).affectedKeys()
                             .hasOnly(['status', 'radius', 'lastUpdated']) ||
                           // Allow updating earnings fields
                           request.resource.data.diff(resource.data).affectedKeys()
                             .hasOnly(['completedOrdersCount', 'totalEarnedValue'])
                         );
        }

        // Rules for orders collection
        match /orders/{orderId} {
          // Allow users to create their own orders
          allow create: if request.auth != null && 
                       request.resource.data.userId == request.auth.uid;
          // Allow users to read their own orders, and vendors/admins to read any order
          allow read: if request.auth != null && 
                     (resource.data.userId == request.auth.uid || 
                      (exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
                       get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role in ['vendor', 'admin'])); // Allow admins too
                       
          // Allow specific updates based on role and order status
          allow update: if request.auth != null && 
                       (
                         // Vendor accepts a PENDING order
                         (exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
                          get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'vendor' &&
                          resource.data.status == 'pending' && // <<< Check current status is pending
                          request.resource.data.diff(resource.data).affectedKeys()
                            .hasOnly(['status', 'assignedVendorId', 'assignedAt']) && // Fields for accepting
                          request.resource.data.status == 'assigned' && // Ensure status is being set to 'assigned'
                          request.resource.data.assignedVendorId == request.auth.uid) || // Ensure vendor assigns themselves

                         // Vendor updates an ASSIGNED or IN_PROGRESS order (e.g., mark in progress/completed)
                         (exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
                          get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'vendor' &&
                          resource.data.assignedVendorId == request.auth.uid && // Can only update THEIR assigned orders
                          resource.data.status in ['assigned', 'in_progress'] && // Check current status
                          request.resource.data.diff(resource.data).affectedKeys()
                            .hasOnly(['status', 
                                      'in_progressTimestamp', 'completedTimestamp',
                                      'startedDeliveryAt', 'completedAt',
                                      'estimatedDeliveryTime', 'actualDeliveryTime']) && // Fields for status changes
                          request.resource.data.status in ['in_progress', 'completed']) || // Ensure status is valid
                          
                         // User cancels a PENDING order (future use example)
                         (resource.data.userId == request.auth.uid && 
                          resource.data.status == 'pending' && // Can only cancel pending orders
                          request.resource.data.diff(resource.data).affectedKeys()
                            .hasOnly(['status']) &&
                          request.resource.data.status == 'cancelled') || // Example: Allow user to set status to 'cancelled'
                          
                         // <<< ADD THIS: User updates payment status on their own order >>>
                         (resource.data.userId == request.auth.uid &&
                          request.resource.data.diff(resource.data).affectedKeys()
                            .hasOnly(['paymentStatus', 'paidAt']) && // Only allow these fields
                          request.resource.data.paymentStatus == 'paid') || // Ensure they are setting it to 'paid'
                          
                         // Admin can update any order (for testing and management)
                         (exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
                          get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin')
                       );
        }

        // Rules for messages collection
        match /messages/{messageId} {
          allow read: if request.auth != null && (
            // User can read messages for their orders
            exists(/databases/$(database)/documents/orders/$(resource.data.orderId)) &&
            get(/databases/$(database)/documents/orders/$(resource.data.orderId)).data.userId == request.auth.uid ||
            // Vendor can read messages for orders assigned to them OR pending orders
            exists(/databases/$(database)/documents/orders/$(resource.data.orderId)) &&
            (get(/databases/$(database)/documents/orders/$(resource.data.orderId)).data.assignedVendorId == request.auth.uid ||
             (exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
              get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'vendor' &&
              get(/databases/$(database)/documents/orders/$(resource.data.orderId)).data.status == 'pending')) ||
            // Admin can read all messages
            isAdmin()
          );
          
          allow create: if request.auth != null && (
            // User can create messages for their orders
            exists(/databases/$(database)/documents/orders/$(request.resource.data.orderId)) &&
            get(/databases/$(database)/documents/orders/$(request.resource.data.orderId)).data.userId == request.auth.uid ||
            // Vendor can create messages for orders assigned to them OR pending orders
            exists(/databases/$(database)/documents/orders/$(request.resource.data.orderId)) &&
            (get(/databases/$(database)/documents/orders/$(request.resource.data.orderId)).data.assignedVendorId == request.auth.uid ||
             (exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
              get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'vendor' &&
              get(/databases/$(database)/documents/orders/$(request.resource.data.orderId)).data.status == 'pending')) ||
            // Admin can create messages
            isAdmin()
          ) && 
          // Ensure sender ID matches the authenticated user
          request.resource.data.senderId == request.auth.uid &&
          // Ensure required fields exist and are of correct type
          request.resource.data.keys().hasAll(['orderId', 'senderId', 'text', 'timestamp']) &&
          request.resource.data.orderId is string &&
          request.resource.data.senderId is string &&
          request.resource.data.text is string &&
          request.resource.data.text.size() > 0;
        }

        // Rules for a specific settings document
        match /settings/main {
           // Allow any authenticated user to read settings
           allow read: if request.auth != null;
           // Allow only admins to write settings (Placeholder - add isAdmin() check later)
           allow write: if request.auth != null && isAdmin(); 
        }

        // Add rules for other collections (e.g., orders) later

      }
    }